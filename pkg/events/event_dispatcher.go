// THIS IS AN AUTOMATICALLY GENERATED CODE! DO NOT EDIT THIS FILE!
// ADD YOUR EVENT TO 'generate_event_dispatcher.go' AND RUN 'go generate'

package events

import (
	"time"
)

// #######################
// INTERFACE DOCUMENTATION
// #######################

// 1. Create EventDispatcher using NewEventDispatcher() function.
// 2. Register your listeners using EventDispatcher.Register<event type name>Listener methods.
// 3. Run event loop by calling EventDispatcher.RunEventLoop() method.
// 4. Trigger events using EventDispatcher.Fire<event type name> methods.

// LISTENER INTERFACES

type UserConnectedListener interface {
	HandleUserConnected(*UserConnected)
}

type UserLeftListener interface {
	HandleUserLeft(*UserLeft)
}

// ##############################
// END OF INTERFACE DOCUMENTATION
// ##############################

const (
	eventQueuesCapacity                                       = 100000
	idleDispatcherSleepTime                     time.Duration = 5 * time.Millisecond
	registeringListenerWhileRunningErrorMessage               = "Tried to register listener while running event loop. Registering listeners is not thread safe therefore prohibited after starting event loop."
)

// PRIVATE EVENT HANDLERS

type eventHandler interface {
	handle()
}

type userConnectedHandler struct {
	event          *UserConnected
	eventListeners []UserConnectedListener
}

func (handler *userConnectedHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserConnected(handler.event)
	}
}

type userLeftHandler struct {
	event          *UserLeft
	eventListeners []UserLeftListener
}

func (handler *userLeftHandler) handle() {
	for _, listener := range handler.eventListeners {
		listener.HandleUserLeft(handler.event)
	}
}

// EVENT DISPATCHER

type EventDispatcher struct {
	running bool

	// EVENT QUEUES

	priority2EventsQueue chan eventHandler

	// LISTENER LISTS

	userConnectedListeners []UserConnectedListener

	userLeftListeners []UserLeftListener
}

// EVENT DISPATCHER CONSTRUCTOR

func NewEventDispatcher() *EventDispatcher {
	return &EventDispatcher{
		running: false,

		// EVENT QUEUES

		priority2EventsQueue: make(chan eventHandler, eventQueuesCapacity),

		// LISTENER LISTS

		userConnectedListeners: []UserConnectedListener{},

		userLeftListeners: []UserLeftListener{},
	}
}

// MAIN EVENT LOOP

func (dispatcher *EventDispatcher) RunEventLoop() {
	dispatcher.running = true

	for {
		select {

		case handler := <-dispatcher.priority2EventsQueue:
			handler.handle()

		default:
			time.Sleep(idleDispatcherSleepTime)
		}
	}
}

func (dispatcher *EventDispatcher) panicWhenEventLoopRunning() {
	if dispatcher.running {
		panic(registeringListenerWhileRunningErrorMessage)
	}
}

// PUBLIC EVENT DISPATCHER METHODS

type QueueFilling struct {
	CurrentLength int
	Capacity      int
}

func (dispatcher *EventDispatcher) QueuesFilling() map[int]QueueFilling {
	filling := make(map[int]QueueFilling)

	filling[2] = QueueFilling{len(dispatcher.priority2EventsQueue), eventQueuesCapacity}

	return filling
}

// UserConnected

func (dispatcher *EventDispatcher) RegisterUserConnectedListener(listener UserConnectedListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userConnectedListeners = append(dispatcher.userConnectedListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserConnected(event *UserConnected) {
	handler := &userConnectedHandler{
		event:          event,
		eventListeners: dispatcher.userConnectedListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}

// UserLeft

func (dispatcher *EventDispatcher) RegisterUserLeftListener(listener UserLeftListener) {
	dispatcher.panicWhenEventLoopRunning()

	dispatcher.userLeftListeners = append(dispatcher.userLeftListeners, listener)
}

func (dispatcher *EventDispatcher) FireUserLeft(event *UserLeft) {
	handler := &userLeftHandler{
		event:          event,
		eventListeners: dispatcher.userLeftListeners,
	}

	dispatcher.priority2EventsQueue <- handler
}
